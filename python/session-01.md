# Pythin Session-01
In this session, the following topics were discussed: 
- `.gitignore` Files 
- Chapter 1 of Python Distilled
- Chapter 1 of Fluent Python
- Mindomo: a Simple Application For Creating Mind Maps
- Obsidian
 
---
## `.gitignore` Files
Sometimes, apart from the codes and project files that we have in our local/remote repository, we may add a `.gitignore` file.   
As it's name suggests, when we add a file's name to the `.gitignore` file, git no longer tracks that files and ignores it. That means git will no longer care about the changes that we make to that file and as a result, does not include it in it's commits.  
Reasons to use a `.gitignore` file in you repository:  
- you have a file in your repository that you don't want to push to github or you just don't want git to track the changes of that file because the file is not a part of the project
- sometimes, you are using a specific IDE(such as PyCharm) or a framework(sunch as Django) which might generate some files which are not related to the actual project. Rather, they are related to the IDE or framework. So you must not push those files. So you just ignore them using the `.gitignore` file  

**Attention:** Assume you are working with Pycharm and Djankgo and you don't know which files to ignore. There are some websites that auto-generate the proper `.gitignore` file to ignore unwanted files generated by your IDE/Platform/Framework. All you need to do is to specify the tools that you are working with.
An example of such websites is:
- [Create useful .gitignore files for your project](https://www.toptal.com/developers/gitignore)

---
##  Chapter 1 of Python Distilled: Python Basics
In this section, a summary of important what was discussed is represented
### 1.1 Running Python
- When using python in a comand line, the variable `_ ` holds the result of the
last operation
- You can exit the interactive interpreter by typing quit() or the EOF
### 1.2 Python Programs
- It is common to use #! to specify the interpreter on the first line of a program, like this:
`#!/usr/bin/env python3`
### 1.3 Primitives, Variables, and Expressions
- Sometimes you might see a type explicitly attached to a name. For example:
`x: int = 42`
The type is merely a hint to improve code readability.Otherwise, it is completely ignored.
- The f-string tool is a useful tool to pretiffy you outputs:
 `print(f'{year:>3d} {principal:0.2f}')` the `{}` is place holder for variables and the `0.2f` tells python to round a float to 2 digits
### 1.4 Arithmetic Operators
- The `//` operator deos truncating division
- It is common to write an expression that updates a value. For example:
`x = x + 1`
`y = y * n`
For these, you can write the following shortened operation instead:
`x += 1`
`y *= n`
### 1.5 Conditionals and Control Flow
- You can use `pass` in the body of `if/elif/else` to do nothing
- Use `raise` to raise an exception
- You can make your code look better by using such syntax:
 `maxval = a if a > b else b`
 instead of:
 `if a > b:`     
  `maxval = a`
  `else:`
  `maxval = b`
- You may see the assignment of a variable and a conditional combined together using the `:=` operator. This is known as an assignment
expression
- Use `break` to break out of the inner-most loop
- Use `continue` to ignore the rest of the body of a loop
### 1.6 Text Strings
- String type is immutable
- Triple-quoted strings (`'''Hey'''`) are useful when the contents of a string literal span multiple lines of text
- Remember that strings support negative indexing: `str[-5:]` is the last 5 characters of `str`
- `s.replace()` replaces a sub-string with another one in `s`
- `s.split()` splits the strings into a list of words
- `s.strip([chrs])` removes leading and trailing whitespace or characters supplied in chrs 
- Use `+` operator to concatenate strings
- When debugging, use repr(s) to produce output because it shows you more information about a value and its type
### 1.7 File Input and Output
- Use the `with` statement to safely open and close a file
- Use `file.read()` method to read the whole content of a file as string at once
### 1.8 Lists
- Items of a list can have different types
- Use `lis.append(object)` method to append an object to a list
- Use `lis.insert(index, object)` method to insert and object to a specific index
- Use `+` operator to concatenate lists
#### `sys.argv` Method
In order to use the `sys.argv` method, you should first `import sys`  
This method, takes all the arguments of a python command and converts them into a list. For example:
`>>>python3 sum.py 2 3 12`
In the `sum.py` script, `sys.argv` equlas `['sum.py', '2', '3', '12']`  
Because the arguments thet we passed to `python3` are `sum.py` and `2` and `3` and `12`
### 1.9 Tuples
- Tuples are immutable
- For creating a tuple with only one element, use the syntax `(item, )`. Note that `(item)` is not a tuple
- You can access the elements of a tuple with index like list. For example:
 `a = (2, 1, -7)`
 `x = a[2]`
Although, contents of a tuple are often unpacked into variables. For examples:
`x, y, z = a`
Or:
`x, y, z = (9, 10, -56) `
- When unpacking, we can ignore some elements of a tuple as follows:
`a = (12, 66, 96)`
`x, _, z = a`
Or:
`a = (1, 2, -1, 5)`
`x, y, _* = a`
- Many times, tuples and lists are used together. For example we might have a list of tuples.
### List Vs Tuple
- Class richness: list objects are rich with various useful methods and attributes. In contrast, tuple objects have very few methods and are very simple.
- Performance: Because of simplicity, tuples are faster and cheaper in terms of memory and time complexity. On the other hand, lists have more option but are weaker in terms of performance compared to tuples.
- Lists can be modified but tuples cannot be modified
- 
---
## Chapter 1 of Fluent Python: The Python Data Model


